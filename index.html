<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  <title>Adaptive Concretization for Parallel Program Synthesis</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- FONT
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/custom.css">

  <!-- Scripts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  <link rel="stylesheet" href="css/github-prettify-theme.css">
  <script src="js/site.js"></script>

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="images/favicon.png">
</head>
<body class="code-snippets-visible">

  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div class="container">

    <div class="navbar-spacer"></div>
    <nav class="navbar">
      <div class="container">
        <ul class="navbar-list">
          <li class="navbar-item"><a class="navbar-link" href="#intro">Intro</a></li>
          <li class="navbar-item">
            <a class="navbar-link" href="#" data-popover="#downloadPopover">Downloads</a>
            <div id="downloadPopover" class="popover">
              <ul class="popover-list">
                <li class="popover-item">
                  <a class="popover-link" href="#OVA">OVA</a>
                </li>
                <li class="popover-item">
                  <a class="popover-link" href="#tar-ball">tar ball</a>
                </li>
                <li class="popover-item">
                  <a class="popover-link" href="#source">source</a>
                </li>
                <li class="popover-item">
                  <a class="popover-link" href="#usage">usage</a>
                </li>
              </ul>
            </div>
          </li>
          <li class="navbar-item">
            <a class="navbar-link" href="#" data-popover="#expNavPopover">Experiments</a>
            <div id="expNavPopover" class="popover">
              <ul class="popover-list">
                <li class="popover-item">
                  <a class="popover-link" href="exp.html#infra">infra</a>
                </li>
                <li class="popover-item">
                  <a class="popover-link" href="exp.html#DB">database</a>
                </li>
                <li class="popover-item">
                  <a class="popover-link" href="exp.html#exp-short">short</a>
                </li>
                <li class="popover-item">
                  <a class="popover-link" href="exp.html#exp-full">full</a>
                </li>
                <li class="popover-item">
                  <a class="popover-link" href="exp.html#exp-raw">raw data</a>
                </li>
              </ul>
            </div>
          </li>
        </ul>
      </div>
    </nav>

    <div class="docs-section" id="intro">
      <h4 class="title">Adaptive Concretization for Parallel Program Synthesis</h4>
      <p>
Program synthesis tools work by searching for an implementation that satisfies
a given specification. Two popular search strategies are <em>symbolic search</em>,
which reduces synthesis to a formula passed to a SAT solver, and
<em>explicit search</em>, which uses brute force or random search to find a solution.
In this paper, we propose adaptive concretization, a novel synthesis algorithm
that combines the best of symbolic and explicit search. Our algorithm works by
partially concretizing a randomly chosen, but likely highly influential,
subset of the unknowns to be synthesized. Adaptive concretization uses an online
search process to find the optimal size of the concretized subset using a combination
of exponential hill climbing and binary search, employing a statistical test to
determine when one degree of concretization is sufficiently better than another.
Moreover, our algorithm lends itself to a highly parallel implementation, further
speeding up search. We implemented adaptive concretization for Sketch, and we
evaluated it on a range of benchmarks. We found adaptive concretization is effective
in practice, outperforming Sketch in many cases, sometimes significantly, and has good
parallel scalability.
      </p>
      <ul>
        <li><a href="http://people.csail.mit.edu/jsjeon/adaptive-concretization/cav2015_submission_174.pdf">PDF</a> (submission)</li>
        <li>
The testing infrastructure and web pages are maintained at
<a href="https://github.com/plum-umd/adaptive-concretization">here</a>.
        </li>
        <li>Last updated: Apr, 2015</li>
      </ul>
    </div>

    <div class="docs-section" id="OVA">
      <h5 class="docs-header">VM image</h5>
      <p>
The easiest way to use Sketch and run experiment is to use VM image:
      </p>
      <div>
        <a class="button button-primary" href="http://people.csail.mit.edu/jsjeon/adaptive-concretization/adaptive-conc.ova">Download OVA</a>
login credential: (
  id: <font color="white">cav15</font>,
  password: <font color="white">cav2015</font>
)
      </div>
      <p>
This VM image includes Sketch, this testing infrastructure, and
<a href="exp.html#DB">database</a> setup.
You can directly move to <a href="exp.html#exp-short">short</a>
version of experiment to learn the usages of this testing infrastructure
and experiments in detail; and then visit
<a href="exp.html#exp-full">full</a> version of experiment
to conduct the whole experiments discussed in the paper.
      </p>
      <p>
Notice that the VM image is set to use just one single core.
This means that even experiments for multi-core will be run on a single core
if you don't change the setting.  To reproduce all the experiments we reported
in the paper, you should use a machine with more than 32 cores
and accordingly change the number of cores for the VM image by yourself.
(Or, read through and follow the other options below,
which are not that difficult.)
      </p>
    </div>

    <div class="docs-section" id="tar-ball">
      <h5 class="docs-header">Tar ball</h5>
      <p>
Another way to build Sketch is to use an easy-to-install tar ball:
      </p>
      <div>
        <a class="button button-primary" href="http://people.csail.mit.edu/jsjeon/adaptive-concretization/sketch-1.6.8.tgz">Download tar ball</a>
      </div>
      <p>
Inside the tar ball, all Java files in sketch-frontend are already compiled,
so all you need to do is building sketch-backend.  Make sure that you have
<code>gcc</code>, <code>g++</code>, <code>bison</code>, and <code>flex</code>.
(You may need to install <code>autoconf</code>, <code>automake</code>,
and <code>libtool</code>, too.)
Then, build the beck-end as follows:
      </p>
<pre><code>.../ae $ tar xvfz sketch-1.6.8.tgz
.../ae $ cd sketch-1.6.8/sketch-backend
.../ae/sketch-1.6.8/sketch-backend $ chmod +x ./configure
.../ae/sketch-1.6.8/sketch-backend $ ./configure
.../ae/sketch-1.6.8/sketch-backend $ make clean; make
</code></pre>
      <p>
Skip to the <a href="#usage">Usage</a> section to learn how to use Sketch.
      </p>
    </div>

    <div class="docs-section" id="source">
      <h5 class="docs-header">Source</h5>
      <p>
In case you are interested, here is a harder way to build Sketch.
To reclaim what we claim in the paper, clone the specific versions of
<a href="https://bitbucket.org/gatoatigrado/sketch-frontend">sketch-frontend</a>
and
<a href="https://bitbucket.org/gatoatigrado/sketch-backend">sketch-backend</a>:
      </p>
<pre><code>.../ae $ hg clone -r 4916b0c679b4f8ab3bb18e5482f5a58d8deae122 \
> https://bitbucket.org/gatoatigrado/sketch-frontend
.../ae $ hg clone -r 4609620d4f62c481c6be0aaac9d8611c0e8ae573 \
> https://bitbucket.org/gatoatigrado/sketch-backend
</code></pre>
      <p>
Make sure that you have <code>java</code>, <code>javac</code>,
<code>gcc</code>, <code>g++</code>, <code>bison</code>, and <code>flex</code>.
(You may need to install <code>autoconf</code>, <code>automake</code>,
and <code>libtool</code>, too.)
Then, build Sketch as follows:
      </p>
<pre><code>.../ae $ cd sketch-frontend
.../ae/sketch-frontend $ make assemble-noarch
</code></pre>
<pre><code>.../ae $ cd sketch-backend
.../ae/sketch-backend $ ./autogen.sh
.../ae/sketch-backend $ chmod +x ./configure
.../ae/sketch-backend $ ./configure
.../ae/sketch-backend $ make clean; make
</code></pre>
      <p>
If you encounter any build errors, please contact the authors.
      </p>
    </div>

    <div class="docs-section" id="usage">
      <h5 class="docs-header">Usage</h5>
      <p>
To use <code>sketch</code> from anywhere,
we recommend you to set up your environment accordingly.
      </p>
      <p>
For the tar ball users:
      </p>
<pre><code>export SKETCH_HOME=/path/to/sketch-1.6.8/sketch-frontend/runtime
export PATH=$PATH:$SKETCH_HOME/..
</code></pre>
      <p>
For the source users:
      </p>
<pre><code>export SKETCH_HOME=/path/to/sketch-frontend
export PATH=$PATH:$SKETCH_HOME/target/sketch-1.6.8-noarch-launchers.dir
</code></pre>
      <p>
If you are using the up-to-date Sketch, double-check Sketch version number,
which may be <code>1.6.9</code>.
You can see the version number while building sketch-frontend.
      </p>
      <p>
Our testing infrastructure takes care of all the Sketch options
that will be explained below.  Therefore, if you are not interested,
you can move to the <a href="exp.html">Experiments</a> page now.
      </p>
      <p>
The option to enable (random) concretization is:
<code>--slv-randassign</code>.
You can also specify the degree of concretization via
<code>--slv-randdegree n</code>.
(Please refer to the paper for the notions of concretization and its degree.)
      </p>
<pre><code>$ sketch --slv-randassign [--slv-randdegree n] ... target.sk
</code></pre>
      <p>
Since concretized values for holes are random,
the UNSAT result from the back-end doesn't mean the given sketch is indeed UNSAT.
That is, if you are sure that the target sketch is satisfiable,
you need to run concretized sub-problems many times until resolved.
The option <code>--slv-parallel</code> will run many instances of sketch-backend
in parallel.  Note that that option merely runs <em>same</em> instances of
sketch-backend in parallel if you don't pass any options about concretization.
Thus, the preferred usage is:
      </p>
<pre><code>$ sketch --slv-parallel --slv-randassign [--slv-randdegree n] ... target.sk
</code></pre>
      <p>
Rather than a fixed degree of concretization,
the option <code>--slv-strategy WILCOXON</code> will adjust the degree adaptively
until it figures out a statistically better degree than another.
      </p>
<pre><code>$ sketch --slv-parallel --slv-randassign --slv-strategy WILCOXON ... target.sk
</code></pre>
      <p>
There are couple more minor options to tune Sketch behavior:
        <ul>
          <li><code>--slv-p-cpus n</code>: number of cores to use (default: 80% of available cores to not exhaust the system)</li>
          <li><code>--slv-p-timeout n</code>: (adaptive) timeout for parallel trials (default: 1 minute)</li>
          <li><code>--slv-p-trials n</code>: number of parallel trials (default: 32 * 32 * 3)</li>
        </ul>
      </p>
    </div>

  </div>
</body>
</html>
